a) In this case, the costly O(n) operation of resizing the array can only be amortized over the 10 calls to push, giving it an amortized cost of n/10. The amortized runtime is now O(n).
b) In this case, the costly O(n) operation of resizing the array can be amortized over n^1/2 additional calls, giving it an amortized cost of n/n^1/2. The amortized runtime is now O(n^1/2).
c) The worst case sequence of pops and pushes is when the stack frequently calls push() when it is full (leading to a costly O(n) resize), then immediately after calls pop() a few times (leading to a costly O(n) resize when the size is less than half of the new capacity), then calls pop() a few times immediately after that (leading to a costly O(n) resize once capacity is reached), then pop() a few times, etc. In this case the resizes of push and pop cannot be amortized over a large amount of calls. The amortized runtime in this case is still O(n). This was not a good idea.
d) In this case, the situation of successive resizes described in c) does not occur. Now, when the stack calls push() when it full (O(n) operation) and then immediately after calls pop(), it will take n/2 successive calls before a resize occurs. The cost can now be amortized over those n/2 calls in the worst case leading to an amortized runtime of 0(1). The solution is much better.